// 如何正确关闭 tcp 连接？

/*
陈硕:
keep read(sockfd) until it return 0, then close(sockfd)
如果没有读全就关闭连接,会发送一个RST到对方,可能导致对方数据无法收全
*/

/*
作者：胡宇光
链接：https://www.zhihu.com/question/48871684/answer/113135138

shutdown(both)还需要close，不然你就泄漏了一个或几个handle或fd以及相关资源。
read返回0表示你收到了对方发来的fin，这可能是对方调用shutdown(send)，也可能是对方调用了close()。从tcp协议本身来说，你是无法知道对方到底是调用了close()还是调用了shutdown(send)的，os的tcp协议栈也不知道。因此此时是否要close取决于你的应用。通常来说如果对方调用的是close，那么你也可以close。否则你不能close，例如对方发送一个包给你并shutdown write然后调用recv，这时候你还可以返回一个或多个包，连接此时处于半关闭状态，可以一直持续。这么做的客户端不多（connect, send, shtudown(send), recv();），但的确有，而且是完全合法的。如果通讯双方都是你自己的代码，那么你知道是哪种情况。如果你不能了解对方的代码，甚至你是个proxy，两边代码你都不了解，那么通常来说你不能close。
很多server/proxy的实现为当read返回0就close，这种实现是错误的，这个实现无法兼容刚才我说的那种情况。对于proxy来说，正确的做法是透传双方的行为。因此，当你read(client_side_socket)返回0时，你应该对另外一端调用shutdown(server_side_socket, send)，这样服务器就会read返回0，你透明的传递了这个行为。那么作为proxy，你什么时候才能close呢？client_socket和server_socket上read都返回了0，或者有任何一方返回了-1时你可以close。当然你也可以考虑设置一个超时时间，如果线路上超过5分钟没有数据你就断开，但这是另一个维度的问题。
关于close，要注意的是默认情况下它是一个异步的过程。作为proxy来说，如果你想避免大量close_wait，那么你可以在close之前shutdown，然后启动一个5s的delaytask，在delaytask里设置超时时间为0的so_linger，然后close，对socket进行hard close。这时候close是同步的，如果此时不能优雅关闭，那么系统会立刻强制关闭。
我没有看muduo的代码。如果你在2处close同一个socket，这是高危行为。因为2次close之间很可能会有一个新socket产生并且值和你第一次close的那个一样。你第二次close就会错误的close了一个不属于你的socket。这种错误非常难查，因此绝对不要干这种事。
*/


/*
TCP 网络编程本质论
我认为，TCP 网络编程最本质的是处理三个半事件：

1. 连接的建立，包括服务端接受 (accept) 新连接和客户端成功发起 (connect) 连接。
2. 连接的断开，包括主动断开 (close 或 shutdown) 和被动断开 (read 返回 0)。
3. 消息到达，文件描述符可读。这是最为重要的一个事件，对它的处理方式决定了网络编程的风格（阻塞还是非阻塞，如何处理分包，应用层的缓冲如何设计等等）。
4. 消息发送完毕，这算半个。对于低流量的服务，可以不必关心这个事件；另外，这里“发送完毕”是指将数据写入操作系统的缓冲区，将由 TCP 协议栈负责数据的发送与重传，不代表对方已经收到数据。

这其中有很多难点，也有很多细节需要注意，比方说：

1. 如果要主动关闭连接，如何保证对方已经收到全部数据？如果应用层有缓冲（这在非阻塞网络编程中是必须的，见下文），那么如何保证先发送完缓冲区中的数据，然后再断开连接。直接调用 close(2) 恐怕是不行的。
2. 如果主动发起连接，但是对方主动拒绝，如何定期 (带 back-off) 重试？
3. 非阻塞网络编程该用边沿触发(edge trigger)还是电平触发(level trigger)？（这两个中文术语有其他译法，我选择了一个电子工程师熟悉的说法。）如果是电平触发，那么什么时候关注 EPOLLOUT 事件？会不会造成 busy-loop？如果是边沿触发，如何防止漏读造成的饥饿？epoll 一定比 poll 快吗？
4. 在非阻塞网络编程中，为什么要使用应用层缓冲区？假如一次读到的数据不够一个完整的数据包，那么这些已经读到的数据是不是应该先暂存在某个地方，等剩余的数据收到之后再一并处理？见 lighttpd 关于 /r/n/r/n 分包的 bug。假如数据是一个字节一个字节地到达，间隔 10ms，每个字节触发一次文件描述符可读 (readable) 事件，程序是否还能正常工作？lighttpd 在这个问题上出过安全漏洞。
5. 在非阻塞网络编程中，如何设计并使用缓冲区？一方面我们希望减少系统调用，一次读的数据越多越划算，那么似乎应该准备一个大的缓冲区。另一方面，我们系统减少内存占用。如果有 10k 个连接，每个连接一建立就分配 64k 的读缓冲的话，将占用 640M 内存，而大多数时候这些缓冲区的使用率很低。muduo 用 readv 结合栈上空间巧妙地解决了这个问题。
6. 如果使用发送缓冲区，万一接收方处理缓慢，数据会不会一直堆积在发送方，造成内存暴涨？如何做应用层的流量控制？
7. 如何设计并实现定时器？并使之与网络 IO 共用一个线程，以避免锁。
*/